---
title: 不同路径
date: 2022-02-24 23:16:33
permalink: /pages/f5a583/
---
⭐⭐：中等

## 题目描述

[不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

![image-20220221174607308](https://cdn.javatv.net/note/20220221174607.png)

```
输入：m = 3,n = 7
输出：28
```

## 解法一

使用动态规划的常规步骤，如下：

**1、定义数组元素的含义**

题目是求从左上角到右下角有多少种路径，如果用函数来表示则是：`dp(i,j)`，假设`i,j`的位置就是目标点，则其取值范围分别为`[0,i)`和`[0,j)`。也就是说**当机器人从左上角走到`(i,j)` 这个位置时，一共有 `dp[i][j]` 种走法**。（很自然的一个二维数组，假设`i`表示向右走，`j`表示向下走）

**2、定义数组元素之间的关系式**

因为机器人每次只能向下或者向右移动一步，假设目标点是`(i,j)`，则分两种情况：

- 向下走一步到达，那么上一步的位置则是`(i-1,j)`；
- 向右走一步到达，那么上一步的位置则是`(i,j-1)`。

因此，总共的走法则有：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`

**3、初始值**

对于初始值，其实我们很好判定，如 `i = 0`或者`j = 0`（注：这里的`0`表示的数组下标），那么此时对于上面的表达式是不存在的，即为负数了，所以我们可以设置边界条件，如下：

- `i = 0`，表示横向只有一个格子，则只能一直往下走，很显然只有一条路径，`dp[0][j] = 1`；
- `j = 0`，表示纵向只有一个格子，则只能一直往右走，很显然也只有一条路径，`dp[i][0] = 1`；

**代码实现**

```java
public int uniquePaths(int m, int n) {
   
    int[][] dp = new int[m][n];
    // 赋初始值
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (int j = 0; j < n; j++) {
        dp[0][j] = 1;
    }
    // 从 1 开始
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    // 注意数组从 0 开始，所以要 -1
    return dp[m-1][n-1];
}
```

**时间复杂度**：O(m*n)

**空间复杂度**：O(m*n)

