---
title: 消息确认机制
date: 2022-01-12 14:52:23
permalink: /pages/afd6b9/
---
## 消息确认机制ACK

对于消费者，就涉及到**消息的确认**：

消费者收到的每一条消息都必须进行确认（自动确认和自行确认）。 

消费者在声明队列时，可以指定 `autoAck` 参数，当 autoAck = false 时，RabbitMQ 会等待消费者显式发回 ack 信号后才从内存(和磁盘，如果是持久化消息的话)中移去消息。否则，RabbitMQ 会在队列中消息被消费后立即删除它。 即分2种情况：

- 自动ACK：消息一旦被接收，消费者自动发送ACK
- 手动ACK：消息接收后，不会发送ACK，需要手动调用

采用消息确认机制后，只要令 autoAck = false，消费者就有足够的时间处理消息(任务)，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为 RabbitMQ 会一直持有消息直到消费者显式调用单条订阅(basicAck )为止。当 autoAck = false 时，对于 RabbitMQ 服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息，一部分是已经投递给消费者，但是还没有收到消费者 ack 信号的消息。如果服务器端一直没有收到消费者的 ack 信号，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。 

假设启动两个消费者 A、B，都可以收到消息，但是其中有一个消费者 A 不会对消息进行确认，当把这个消费者 A 关闭后，消费者 B 又会收到本来发送给消费者 A 的消息。所以我们一般使用手动确认的方法是，将消息的处理放在 try/catch 语句块中，成功处理了，就给 RabbitMQ 一个确认应答，如果处理异常了，就在 catch 中，进行消息的拒绝（下文会讲）。

RabbitMQ 不会为未 ack 的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开。这么设计的原因是 RabbitMQ 允许消费者消费一条消息的时间可以很久很久。

因此，对于如何选择，主要看消息的重要性：

- 如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便
- 如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。

**常见问题** 

1. **如果消息达到无人订阅的队列会怎么办？** 

   消息会一直在队列中等待，RabbitMq 默认队列是无限长度的。 

2. **多个消费者订阅到同一队列怎么办？** 

   消息以循环的方式发送给消费者，每个消息只会发送给一个消费者。 

3. **消息路由到了不存在的队列怎么办？**

   一般情况下，RabbitMq 会忽略，当这个消息不存在，也就是这消息丢了。

对于上述问题，都在后面的实例中进行验证。
