---
layout: post
title: 慢查询
---

# 慢查询
## 什么是慢查询

许多存储系统（例如 MySQL）提供慢查询日志帮助开发和运维人员定位系统存在的慢操作。所谓慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阀值，就将这条命令的相关信息（例如：发生时间，耗时，命令的详细信息）记录下来，Redis 也提供了类似的功能。 

Redis 客户端执行一条命令分为如下 4 个部分：

![image-20211222150417302](https://cdn.javatv.net/note/20211222150417.png)

需要注意的是，慢查询只统计步骤  3 的时间，所以没有慢查询并不代表客户端没有超时问题。 

## 慢查询配置

对于任何慢查询功能,需要明确两件事：多慢算慢，也就是预设阀值怎么设置？慢查询记录存放在哪？ 

Redis 提供了 `slowlog-log-slower-than` 和 `slowlog-max-len` 配置来解决这两个问题。

- **slowlog-log-slower-than**：就是预设阀值，它的单位是微秒(1 秒 = 1000 毫秒 = 1 000 000 微秒)，默认值是 10000，假如执行了一条很慢的命令（例如 keys *)，如果它的执行时间超过了 10000 微秒，也就是 10 毫秒，那么它将被记录在慢查询日志中。 

  如果 slowlog-log-slower-than=0 表示会记录所有的命令，slowlog-log-slower-than<0 对于任何命令都不会进行记录。 

- **slowlog-max-len**：用来设置慢查询日志最多存储多少条，并没有说明存放在哪。 

  实际上 Redis 使用了一个列表来存储慢查询日志，slowlog-max-len 就是列表的最大长度。当慢查询日志列表被填满后，新的慢查询命令则会继续入队，队列中的第一条数据机会出列。 

  虽然慢查询日志是存放在 Redis 内存列表中的，但是 Redis 并没有告诉我们这里列表是什么，而是通过一组命令来实现对慢查询日志的访问和管理。 

## 慢查询操作命令

**获取慢查询日志** 

```
slowlog get [n] 
```

参数 n 可以指定查询条数。

```shell
127.0.0.1:6379> slowlog get 10
1) 1) (integer) 0
   2) (integer) 1640071791
   3) (integer) 22
   4) 1) "keys"
      2) "*"
   5) "127.0.0.1:50056"
   6) ""
```

可以看到每个慢查询日志有 6 个属性组成，分别是慢查询日志的标识 id、发生时间戳、命令耗时（单位微秒）、执行命令和参数，客户端 IP、端口和客户端名称。

**获取慢查询列表当前的长度**

```
slowlog len
```

**对慢查询列表清理（重置）**

```
slowlog reset
```

再查 slowlog len 此时返回 0。

## 慢查询建议

慢查询功能可以有效地帮助我们找到 Redis 可能存在的瓶颈，但在实际使用过程中要注意以下几点：

1. slowlog-max-len 配置建议

   建议调大慢查询列表，记录慢查询时 Redis 会对长命令做截断操作，并不会占用大量内存。增大慢查询列表可以减缓慢查询被剔除的可能，例如线上可设置为 1000 以上。 

2. slowlog-log-slower-than 配置建议

   默认值超过 10 毫秒判定为慢查询，需要根据 Redis 并发量调整该值。由于 Redis 采用单线程响应命令，对于高流量的场景，如果命令执行时间在 1 毫秒以上，那么 Redis 最多可支撑 QPS 不到 1000。因此对于高 QPS 场景的 Redis 建议设置为 1 毫秒或者更低比如 100 微秒。 

慢查询只记录命令执行时间，并不包括命令排队和网络传输时间。因此客户端执行命令的时间会大于命令实际执行时间。因为命令执行排队机制，慢查询会导致其他命令级联阻塞，因此当客户端出现请求超时，需要检查该时间点是否有对应的慢查询，从而分析出是否为慢查询导致的命令级联阻塞。 

由于慢查询日志是一个先进先出的队列，也就是说如果慢查询比较多的情况下，可能会丢失部分慢查询命令，为了防止这种情况发生，可以定期执行 slow get 命令将慢查询日志持久化到其他存储中。