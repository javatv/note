---
layout: post
title: 缓存一致性解决方案
---

# 缓存一致性解决方案

## 谈谈一致性

![image-20220401104954837](https://cdn.javatv.net/20220401104954.png)

一致性就是数据保持一致，在分布式系统中，可以理解为多个节点中数据的值是一致的。

- 强一致性：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大；
- 弱一致性：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态；
- 最终一致性：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型。

## 三个经典的缓存模式

缓存可以提升性能、缓解数据库压力，但是使用缓存也会导致数据不一致性的问题。一般我们是如何使用缓存呢？有三种经典的缓存模式：

- Cache-Aside Pattern
- Read-Through/Write through
- Write behind

### Cache-Aside Pattern

Cache-Aside Pattern，即旁路缓存模式，它的提出是为了尽可能地解决缓存与数据库的数据不一致问题。

#### Cache-Aside 的读流程

Cache-Aside Pattern 的读请求流程如下：

1. 读的时候，先读缓存，缓存命中的话，直接返回数据；
2. 缓存没有命中的话，就去读数据库，从数据库取出数据，放入缓存后，同时返回响应。

![image-20220401105423198](https://cdn.javatv.net/20220401105423.png)

#### Cache-Aside 写流程

更新的时候，先更新数据库，然后再删除缓存。

![image-20220401105537004](https://cdn.javatv.net/20220401105537.png)

### Read-Through/Write-Through

Read/Write Through，即读写穿透模式，服务端把缓存作为主要数据存储。应用程序跟数据库缓存交互，都是通过抽象缓存层完成的。

#### Read-Through读流程

从缓存读取数据，读到直接返回，如果读取不到的话，从数据库加载，写入缓存后，再返回响应。

![image-20220401105709416](https://cdn.javatv.net/20220401105709.png)

这个简要流程是不是跟Cache-Aside很像呢？

其实 Read-Through 就是多了一层 Cache-Provider，流程如下：

![image-20220401105815840](https://cdn.javatv.net/20220401105815.png)

Read-Through实际只是在Cache-Aside之上进行了一层封装，它会让程序代码变得更简洁，同时也减少数据源上的负载。

#### Write-Through写流程

Write-Through模式下，当发生写请求时，也是由缓存抽象层完成数据源和缓存数据的更新，流程如下：

![image-20220401110247818](https://cdn.javatv.net/20220401110247.png)

### Write behind

Write behind ，即异步缓存写入模式，Write behind 跟 Read-Through/Write-Through 有相似的地方，都是由 Cache Provider 来负责缓存和数据库的读写。它两又有个很大的不同：Read/Write Through 是同步更新缓存和数据的，Write Behind则是只更新缓存，不直接更新数据库，通过批量异步的方式来更新数据库。

![image-20220401110443456](https://cdn.javatv.net/20220401110443.png)

这种方式下，缓存和数据库的一致性不强，对一致性要求高的系统要谨慎使用。但是它适合频繁写的场景，MySQL 的 InnoDB Buffer Pool 机制就使用到这种模式。

### 三种模式的比较

Cache Aside 更新模式实现起来比较简单，但是需要维护两个数据存储:

- 一个是缓存（Cache）
- 一个是数据库（Repository）。

Read/Write Through 的写模式需要维护一个数据存储（缓存），实现起来要复杂一些。

Write Behind Caching 更新模式和 Read/Write Through 更新模式类似，区别是 Write Behind Caching 更新模式的数据持久化操作是**异步的**，但是 Read/Write Through 更新模式的数据持久化操作是**同步的**。

Write Behind Caching 的优点是直接**操作内存速度快**，多次操作可以合并持久化到数据库。缺点是数据可能会丢失，例如系统断电等。

## Cache-Aside 的问题

### 问题一

Cache-Aside在写入请求的时候，为什么是删除缓存而不是更新缓存呢？

![image-20220401105537004](https://cdn.javatv.net/20220401105537.png)

我们在操作缓存的时候，到底应该删除缓存还是更新缓存呢？我们先来看个例子：

1. 线程 A 先发起一个写操作，第一步更新数据库
2. 线程 B 再发起一个写操作，第二步更新数据库

![image-20220401111226558](https://cdn.javatv.net/20220401111226.png)

**现在，由于网络等原因，线程 B 先更新了缓存，线程 A 更新缓存**。

这时候，缓存保存的是 A 的数据（老数据），数据库保存的是 B 的数据（新数据），数据不一致了，脏数据出现啦。如果是删除缓存取代更新缓存则不会出现这个脏数据问题。

更新缓存相对于删除缓存，还有两点劣势：

1. 如果你写入的缓存值，是经过复杂计算才得到的话。 更新缓存频率高的话，就浪费性能啦。
2. 在写多读少的情况下，数据很多时候还没被读取到，又被更新了，这也浪费了性能呢(实际上，写多的场景，用缓存也不是很划算了)

任何的措施，也不是绝对的好， 只有分场景看是不是适合，更新缓存的措施，也是有用的：在读多写少的场景，价值大。

### 问题二

双写的情况下，先操作数据库还是先操作缓存？

假设有 A、B 两个请求，请求 A 做更新操作，请求 B 做查询读取操作，A、B 两个请求的操作流程如下：

1. 线程 A 发起一个写操作，第一步 del cache
2. 此时线程 B 发起一个读操作，cache miss
3. 线程 B 继续读 DB，读出来一个老数据
4. 然后线程 B 把老数据设置入 cache
5. 线程 A 写入 DB 最新的数据

酱紫就有问题啦，缓存和数据库的数据不一致了。

![image-20220401135022625](https://cdn.javatv.net/20220401135022.png)

缓存保存的是老数据，数据库保存的是新数据。因此，Cache-Aside 缓存模式，选择了先操作数据库而不是先操作缓存。

## 缓存的一致性方案

我们要知道**缓存是通过牺牲强一致性来提高性能的**。这是由**CAP理论**决定的。缓存系统适用的场景就是非强一致性的场景，它属于 CAP 中的 AP。

一般有如下 3 种方案保证数据库与缓存的一致性：

1. 延时双删策略；
2. 删除缓存重试机制；
3. 读取biglog异步删除缓存。

### 延时双删策略

什么是延时双删？延时双删的步骤如下：

1. 先删除缓存；
2. 再更新数据库；
3. 休眠一会（比如 1 秒），再次删除缓存。

![image-20220401140005896](https://cdn.javatv.net/20220401140005.png)

这种做法可以将 1s 内造成的造数据删除。

那么，这个 1 秒怎么确定的，具体该休眠多久呢？

针对上面的情形，自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百 ms 即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。

### 删除缓存重试机制

因此，对于 Redis 缓存一致性来说，通常的做法是删除缓存，那么既然存在删除这一动作，如果在删除阶段出现问题，导致数据并没有被删除，那么此时每次查询都是错误数据。这又怎么解决呢？

**利用消息队列进行删除的补偿重试**

1. 先对数据库进行更新操作；
2. 在对 Redis 进行删除操作的时候发现报错，删除失败；
3. 此时将 Redis 的 key 作为消息体发送到消息队列中；
4. 系统接收到消息队列发送的消息后；
5. 再次对 Redis 进行删除操作。

![image-20220401140700178](https://cdn.javatv.net/20220401140700.png)

### 同步biglog异步删除缓存

重试删除缓存机制有一个缺点就是会对业务代码造成大量的侵入，深深的耦合在一起，所以这时会有一个优化的方案，我们知道对 MySQL 数据库更新操作后再 Binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 MySql 数据库的 Binlog 日志对缓存进行操作。

（后续补充~）