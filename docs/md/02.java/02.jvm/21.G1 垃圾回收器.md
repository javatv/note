---
layout: post
title: G1 垃圾回收器
---

# G1 垃圾回收器

## 设计思想

随着 JVM 中内存的增大，STW 的时间成为 JVM 急迫解决的问题，但是如果按照传统的分代模型，总跳不出 STW 时间不可预测这点。为了实现 STW 的时间可预测，首先要有一个思想上的改变。G1 将堆内存**化整为零**，将堆内存划分成多个大小相等独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。回收器能够对扮演不同角色的 Region 采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。

**Region到底是什么** ？

Region 可能是 Eden，也有可能是 Survivor，也有可能是 Old，另外 Region 中还有一类特殊的 Humongous 区域，专门用来存储大对象。 G1 认为只要大小超过了一个 Region 容量一半的对象即可判定为大对象。每个 Region 的大小可以通过参数`-XX:G1HeapRegionSize` 设定，取值范围为 1MB~32MB，且应为 2 的 N 次幂。而对于那些超过了整个 Region 容量的超级大对象，将会被存放在 N 个连续的 Humongous Region 之中，G1 的进行回收大多数情况下都把 Humongous Region 作为老年代的一部分来进行看待。

![image-20210823160306373](https://cdn.javatv.net/note/20210823160306.png)

因此，对于G1最主要的特点是**G1的内存区域是不固定的**。如下E变为S，O变为了E：

![image-20210824001443514](https://cdn.javatv.net/note/20210824001443.png)

## 运行过程 

G1 的运作过程大致可划分为以下四个步骤：

1. **初始标记**，仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。 这个阶段需要停顿线程，但耗时很短，而且是借用进行 Minor GC 的时候同步完成的，所以 G1 收集器在这个阶段实际并没有额外的停顿。 

   **TAMS 是什么？**

   要达到 GC 与用户线程并发运行，必须要解决回收过程中**新对象的分配**（虽然我在进行垃圾回收，但是还是会有新对象产生），所以 G1 为每一个 Region 区域设计了两个名为 **TAMS**（Top at Mark Start）的指针，从 Region 区域划出一部分空间用于记录并发回收过程中的新对象。这样的对象认为它们是存活的，不纳入垃圾回收范围。 

2. **并发标记**，从 GC Root 开始对堆中对象进行**可达性分析**，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后 ，并发时有引用 变动的对象，这些对象会漏标 ， 漏标的对象会被一 个叫做**SATB**(snapshot-at-the-beginning)算法来解决（不理解先不急，往下看）。

3. **最终标记**，对用户线程做另一个短暂的暂停，用于处理并发阶段结后仍遗留下来的最后那少量的 SATB 记录(漏标对象)。 

4. **筛选回收**，负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划（也就是说用户可以指定停顿时间），可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作**涉及存活对象的移动**，是必须暂停用户线程，由多条收集器线程并行完成的。

![image-20210823162708954](https://cdn.javatv.net/note/20210823162708.png)

## 存在的问题

没有一款垃圾收集器是完美无缺的，只能分场景选择最适合的垃圾收集器，对于于 G1来说，主要存在以下问题：

1. **跨代引用**，堆空间通常被划分为新生代和老年代。由于新生代的垃圾收集通常很频繁，如果老年代对象引用了新生代的对象，那么回收新生代的话，需要跟踪从老年代到新生代的所有引用，所以要避免每次 `Young GC` 时扫描整个老年代，减少开销。
2. **并发情况下的漏标问题**，通过三色标记来分析。

![image-20210826234601731](https://cdn.javatv.net/note/20210826234608.png)

## 三色标记（重点）

针对CMS和G1存在的漏标问题，JVM通过三色标记算法来解决。

在三色标记法之前的算法叫 **Mark-And-Sweep**（标记清除）。这个算法会设置一个标志位来记录对象是否被使用。最开始所有的标记位都是 0，如果发现对象是可达的就会置为 1，一步步下去就会呈现一个类似树状的结果。等标记的步骤完成后，会将未被标记的对象统一清理，再次把所有的标记位设置成 0 方便下次清理。 

这个算法最大的问题是 GC 执行期间需要把整个程序完全暂停，不能异步进行 GC 操作。因为在不同阶段标记清扫法的标志位 0 和 1 有不同的含义，那么新增的对象无论标记为什么都有可能意外删除这个对象。对实时性要求高的系统来说，这种需要长时间挂起的标记清扫法是不可接受的。所以就需要一个算法来解决 GC 运行时程序长时间挂起的问题，那就三色标记法。

三色标记最大的好处是可以**异步执行**，从而可以以中断时间极少的代价或者完全没有中断来进行整个 GC。

根据GC Roots可达性分析算法遍历对象的过程中，按照对象**是否访问过**这个条件标记成以下三种颜色：

- **黑色**：根对象，或者该对象与它的子对象都被扫描过。 
- **灰色**：对本身被扫描，但是还没扫描完该对象的子对象。
- **白色**：未被扫描对象，如果扫描完所有对象之后，最终为白色的为不可达对象，既垃圾对象。

### 存在的问题

需要注意的是，对象是否需要被回收主要是通过可达性分析来判断的，但是在GC的并发标记过程中，程序还是在跑的状态，因此对象之间的引用可能会发生改变，这样可能出现两种后果：

- **多标**，把原本死亡的对象错误标记为存活，导致的后果是在本次垃圾回收不会收集。

- **漏标**，把原本存活的对象错误标记为已死亡，这就是非常致命的后果了，程序肯定会因此发生错误。如下：

  ![image-20210823192817707](https://cdn.javatv.net/note/20210823192817.png)

### 针对CMS的解决方案-增量更新

对于存在的漏标问题，CMS主要是采用增量更新算法（Incremental Update）来解决。

什么是增量更新？

> 当一个白色对象被一个黑色对象引用，将黑色对象重新标记为灰色，让垃圾回收器重新扫描。

![image-20210823223542081](https://cdn.javatv.net/note/20210823223549.png)

**有何缺点？**

上面重新扫描的情况是比较简单的，一旦A对象的引用很多，那必定会扫描这个黑色对象的所有引用，耗时增加。

### 针对G1的解决方案-SATB

对于G1来讲，主要是通过SATB(snapshot-at-the-beginning)的方式来处理，简单来说就是在标记之前记录下一个快照（可理解为照片），然后再回收之前和前面的快照进行对比即可，其步骤可以简单的描述为：

1. 如下图，在灰色对象B取消对白色对象的引用之前（即`B.c=null`），先把它记录下来。

   ![image-20210823225100699](https://cdn.javatv.net/note/20210823225100.png)

2. 在线程1和线程2完成标记之前在对比，发现原来B和C的连线断了，而A和C之间却相连，也就是引用。

   ![image-20210823230117421](https://cdn.javatv.net/note/20210823230117.png)

3. 再以这个引用指向的白色对象为根，直接对它的引用进行扫描。

   ![image-20210823230411839](https://cdn.javatv.net/note/20210823230411.png)

 所以，SATB可以简单理解为，**当一个灰色对象取消了对白色对象的引用，那么这个白色对象变为灰色下次继续被扫描**。这也就回到了上面讲的G1运行过程中的第3步，**最终标记**。

**有何缺点？**

如果说在快照对比的时候发现这个白色对象并没有黑色对象去引用它，但是对比之后仍然把它置为灰色，此时本应该是要被回收的，但实际还是没有被回收，在这次的GC存活下来，这就是所谓的浮动垃圾，但相比增量更新来说，只是浪费了一点空间，但是却节约了时间。

**为什么会存在漏标对象？**

分析了漏标问题的解决方案，我们可以得出如果**产生漏标对象**，必然：

1. 至少有一个黑色对象（也就是被标记的对象）指向了一个白色对象。
2. 删除了灰色对象到白色对象的直接或间接引用。

**为什么G1用SATB？CMS用增量更新？**

## 跨代引用

堆空间通常被划分为新生代和老年代，所谓跨代引用，一般是指老年代对象引用了新生代的对象。如下图的X和Y引用：

![image-20210824102850321](https://cdn.javatv.net/note/20210824102850.png)

我们知道新生代的垃圾收集通常很频繁（朝生夕死），如果老年代对象引用了新生代的对象，那么在回收新生代（`Young GC`）的时候，需要跟踪从老年代到新生代的所有引用。

### 记忆集

跨代引用主要存在于`Young GC`的过程中，除了常见的`GC Roots`之外，**如果老年代有对象引用了的新生代对象，那么老年代的对象也属于`GC Roots`（如上图中的老年代对象`B和C`）对象**，但是如果每次进行`Young GC`我们都需要扫描一次老年代的话，那我们进行垃圾回收的代价实在是太大了，因此收集器**在新生代上建立一个全局的称为记忆集的数据结构来记录这种引用关系。**

`Rset(Remember Set)`，简单来说就是一种抽象数据结构用来存老年代对象**对**新生代的引用（即引用X和Y）。

![image-20210824154143386](https://cdn.javatv.net/note/20210824154150.png)

### 卡表

卡表（CardTable）在很多资料上被认为是**对记忆集的实现**（我其实不大能理解，但先这样吧😂，**它定义了记忆集的记录精度、与堆内存的映射关系等**），由于在`Young GC`的过程中，需要扫描整个老年代，效率非常低，所以 JVM 设计了卡表，如果一个老年代的卡表中有对象指向新生代， 就将它设为 `Dirty`（标志位 1，反之设为0），下次扫描时，只需要扫描卡表上是 `Dirty` 的内存区域即可。 而卡表和记忆集的关系可以理解为一个HashMap，类似于下图的样子。

![image-20210824162608313](https://cdn.javatv.net/note/20210824162608.png)

这个时候根据记忆集合卡表的记录，我可以直接确定扫描记忆集确定`Card[1]`的位置，而不需要扫描整个老年代。

在Hotspot虚拟机中，卡表是一个字节数组，数组的每一项对应着内存中的某一块连续地址的区域，即数组的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作**卡页**(Card Page)。 一般来说，卡页大小都是以 2 的 N 次幂的字节数，假设使用的卡页是 2 的 10 次幂，即 1M，内存区域的起始地址是 0x0000 的话，数组 CARD_TABLE 的第 0、1、2 号元素，分别对应了地址范围为 `0x0000~0x03FF、0x0400 ~ 0x07FF、0x0800~0x011FF` 的卡页内存（0x03FF，十六进制转为十进制也就是1024k=1M）。

### G1中的记忆集

再次说明，**G1的内存区域是不固定的**，是一块一块的区域（Region），所以每一个Region需要知道有哪些Region的引用指向了它，也就是说在 G1 中是每一个 Region 都需要一个 RSet 的内存区域，导致有 G1 的 RSet 可能会占据整个堆容量的 20%乃至更多。

对于CMS来说是分代收集（老年代一个内存空间）只需要一份，所以就内存占用来说，G1占用的内存需求更大，虽然 G1 的优点很多，但是我们不推荐在堆空间比较小的情况下使用 G1，尤其小于 6 个 G。